import{r as g}from"./index-F28aNuxU.js";import{I as _,R as j}from"./context-2JaK5s97.js";import{g as k,a as G}from"./i18nInstance-DBIXdvxg.js";const $=(e,n,s,a)=>{var t,u,p,w;const o=[s,{code:n,...a||{}}];if((u=(t=e==null?void 0:e.services)==null?void 0:t.logger)!=null&&u.forward)return e.services.logger.forward(o,"warn","react-i18next::",!0);m(o[0])&&(o[0]=`react-i18next:: ${o[0]}`),(w=(p=e==null?void 0:e.services)==null?void 0:p.logger)!=null&&w.warn?e.services.logger.warn(...o):console!=null&&console.warn&&console.warn(...o)},O={},E=(e,n,s,a)=>{m(s)&&O[s]||(m(s)&&(O[s]=new Date),$(e,n,s,a))},P=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,P(e,s))},A=(e,n,s,a)=>{if(m(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(o=>{e.options.ns.indexOf(o)<0&&e.options.ns.push(o)}),e.loadLanguages(n,P(e,a))},U=(e,n,s={})=>!n.languages||!n.languages.length?(E(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,o)=>{var t;if(((t=s.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!o(a.isLanguageChangingTo,e))return!1}}),m=e=>typeof e=="string",J=e=>typeof e=="object"&&e!==null,W=(e,n)=>{const s=g.useRef();return g.useEffect(()=>{s.current=e},[e,n]),s.current},F=(e,n,s,a)=>e.getFixedT(n,s,a),X=(e,n,s,a)=>g.useCallback(F(e,n,s,a),[e,n,s,a]),D=(e,n={})=>{var R,v,z,L;const{i18n:s}=n,{i18n:a,defaultNS:o}=g.useContext(_)||{},t=s||a||k();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new j),!t){E(t,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(f,l)=>m(l)?l:J(l)&&m(l.defaultValue)?l.defaultValue:Array.isArray(f)?f[f.length-1]:f,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}(R=t.options.react)!=null&&R.wait&&E(t,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const u={...G(),...t.options.react,...n},{useSuspense:p,keyPrefix:w}=u;let r=o||((v=t.options)==null?void 0:v.defaultNS);r=m(r)?[r]:r||["translation"],(L=(z=t.reportNamespaces).addUsedNamespaces)==null||L.call(z,r);const d=(t.isInitialized||t.initializedStoreOnce)&&r.every(i=>U(i,t,u)),M=X(t,n.lng||null,u.nsMode==="fallback"?r:r[0],w),C=()=>M,x=()=>F(t,n.lng||null,u.nsMode==="fallback"?r:r[0],w),[b,T]=g.useState(C);let y=r.join();n.lng&&(y=`${n.lng}${y}`);const I=W(y),N=g.useRef(!0);g.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=u;N.current=!0,!d&&!p&&(n.lng?A(t,n.lng,r,()=>{N.current&&T(x)}):S(t,r,()=>{N.current&&T(x)})),d&&I&&I!==y&&N.current&&T(x);const f=()=>{N.current&&T(x)};return i&&(t==null||t.on(i,f)),c&&(t==null||t.store.on(c,f)),()=>{N.current=!1,t&&(i==null||i.split(" ").forEach(l=>t.off(l,f))),c&&t&&c.split(" ").forEach(l=>t.store.off(l,f))}},[t,y]),g.useEffect(()=>{N.current&&d&&T(C)},[t,w,d]);const h=[b,t,d];if(h.t=b,h.i18n=t,h.ready=d,d||!d&&!p)return h;throw new Promise(i=>{n.lng?A(t,n.lng,r,()=>i()):S(t,r,()=>i())})};export{D as u};
